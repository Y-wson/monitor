<!--
 * @Author: your name
 * @Date: 2021-12-20 22:46:52
 * @LastEditTime: 2021-12-20 22:46:53
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /frontDemo/调用栈/测试.md
-->

---

## theme: channing-cyan

### 1.实现防抖函数

防抖函数原理：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时

防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行

`使用场景:`

- 按钮提交场景：防止多次提交按钮，只执行最后提交的一次。
- 像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。

`要返回一个函数`：

```js
let debounce = (fn, time) => {
  let timer = null;
  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(fn, time);
  };
};
```

### 2.实现节流函数

节流函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效

`使用场景：`

- 像 dom 的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多
- 缩放场景：监控浏览器`resize`

```js
const throttle = (fn, time) => {
  let now = 0;
  let preTime = 0;
  return function (...args) {
    now = new Date();
    if (now - preTime > time) {
      fn.apply(this, args);
      preTime = new Date();
    }
  };
};
```

### 3.实现一个浅拷贝

简洁版本

```js
const newObj = JSON.parse(JSON.stringify(oldObj));
```

**局限性：**

- 他无法实现对函数 ,RegExp, Date, Set, Map 等特殊对象的克隆
- 对象有循环引用,会报错

```
const a = {val:2};
a.target = a;
```

拷贝`a`会出现系统栈溢出，因为出现了无限递归的情况。

```js
export function shallowClone(source) {
  const target = {};
  for (let i in source) {
    if (source.hasOwnProperty(i)) {
      // 重点
      target[i] = source[i];
    }
  }
  return target;
}
```

### 4.实现一个深拷贝

思路：
调用深拷贝方法，若属性为值类型，则直接返回；若属性为引用类型，则递归遍历。这就是我们在解这一类题时的核心的方法。

```js
function deepClone(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  let copy = {};

  if (obj.construct === Array) {
    copy = [];
  }
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      copy[i] = deepClone(obj[i]);
    }
  }
  return copy;
}
```

这只是面试够用版

我们再来看一下
简洁版本

```js
const newObj = JSON.parse(JSON.stringify(oldObj));
```

**局限性：**

- 他无法实现对函数 ,RegExp, Date, Set, Map 等特殊对象的克隆
- 对象有循环引用,会报错

拿我们就来解决这两个问题

1.解决循环应用，那么我们就可以使用 map 就行记录，如果是已经被拷贝过的对象，拿我们就直接返回

```js
function deepClone(obj, map = new Map()) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (map.get(obj)) {
    return obj;
  }
  map.set(obj, true);
  let copy = {};
  if (obj.construct === Array) {
    copy = [];
  }
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      copy[i] = deepClone(obj[i]);
    }
  }
  return copy;
}
```

问题又来了，map 成了强引用，在程序执行完之前，map 一直不会被垃圾回收掉，拿我们只需要把 Map 替换成 weakMap 就可以了

2.无法实现对函数，RegExp,Date,Set,Map

这些类型分为可比遍历对象和不可遍历对象

可遍历的

```js
const canTraverse = {
  "[object Map]": true,
  "[object Set]": true,
  "[object Array]": true,
  "[object Object]": true,
  "[object Arguments]": true,
};
```

不可遍历的

```js
const boolTag = "[object Boolean]";
const numberTag = "[object Number]";
const stringTag = "[object String]";
const dateTag = "[object Date]";
const errorTag = "[object Error]";
const regexpTag = "[object RegExp]";
const funcTag = "[object Function]";
```

然后在针对不同的可遍历的和不可遍历的用不同的操作方法

```js
const getType = (target) => Object.prototype.toString.call(target);
const canTraverse = {
  "[object Map]": true,
  "[object Object]": true,
};

function deepClone(obj, map = new Map()) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (map.get(obj)) {
    return obj;
  }
  map.set(obj, true);
  let copy = {};
  if (canTraverse[getType[obj]]) {
    // 针对可遍历的如果是对象的话
    for (let i in obj) {
      if (obj.hasOwnProperty(i)) {
        copy[i] = deepClone(obj[i]);
      }
    }
  } else {
    // 针对不可遍历的，如果是date的话

    if (getType(obj) === "[object Date]") {
      // 创建一个新的对象，值为原来的值
      copy = new obj.constructor(obj);
    }
  }
  return copy;
}
```

### 4.实现一个 call 函数

`作用`:改变函数中的 this 指向，并执行函数

`注意点`:

- 类数组上不存在数组的方法，所以 arguments 不能使用 slice 方法,可以使用 Array.prototype.slice.call()或 Array.from()能把类数组对象转化成数组
- 原理：利用 context.xxx = this;

```js
Function.prototype.myCall = function () {
  let context = arguments[0] || window;
  context.fn = this;
  const params = [...arguments].slice(1);
  const result = context.fn(...params);
  return result;
};
```

### 5.实现 apply 方法

`注意点`:apply 方法和 call 方法的不同其实就是参数的不同，所以我们能轻易的写出 apply 方法

```js
Function.prototype.myApply = function () {
  let context = arguments[0];
  context.fn = this;
  const result = context.fn(...arguments[1]);
  return result;
};
```

### 6.实现 bind 方法

`注意点`

- 返回一个函数
- 考虑 context 为 null 的时候

```js
Function.prototype.myBind = function (context) {
  const outArgs = [...arguments].slice(1);
  return function (...innerArgs) {
    this.apply(context || window, [...outArgs, ...innerArgs]);
  };
};
```

### 7.实现 Event(event bus)

event bus 既是 node 中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础

思路：

- 步骤一：建立一个对象，每次 on 的参数就是在给对象添加一个 key，key 的值为一个数组，
- 步骤二：emit 就是执行对应的数组
- 步骤三：肯定是一个闭包，要不然没法共用

```js
const Event = (function () {
  const _funMap = {};
  return {
    on: (type, callback) => {
      if (_funMap[type]) {
        if (!_funMap[type].includes[callback]) {
          _funMap[type].push(callback);
        }
      } else {
        _funMap[type] = [callback];
      }
    },
    emit: (type, ...payload) => {
      if (!_funMap[type]) return;
      _funMap[type].forEach((fn) => fn(payload));
    },
  };
})();
```

### 8.实现 instanceOf 方法

思路：

- 步骤 1：先取得当前类的原型，当前实例对象的原型链

- ​ 步骤 2：一直循环（执行原型链的查找机制）

  - 取得当前实例对象原型链的原型链（`proto = proto.__proto__`，沿着原型链一直向上查找）
  - 如果 当前实例的原型链`__proto__`上找到了当前类的原型`prototype`，则返回 `true`
  - 如果 一直找到`Object.prototype.__proto__ == null`，`Object`的基类(`null`)上面都没找到，则返回 `false`

  ```js
  function myInstanceof(left, right) {
    let proto = Object.getPrototypeOf(left);
    while (true) {
      if (proto == null) return false;
      if (proto == right.prototype) return true;
      proto = Object.getPrototypeOf(proto);
    }
  }
  ```

### 9.实现 new

细心的同学会发现 new 和继承实现上很相近，继承请看第 11

继承属性：用 call 或者 apply 都可以
继承方法并返回一个新的对象： const instance = Object.create(fn.prototype);Object.create 是创建了父类原型的副本，与父类原型完全隔离
判断是否是对象：返回不同的值

```
function myNew(fn,...args){
  const instance = Object.create(fn.prototype);
  const res = fn.apply(instance,args);
  return typeof res ==='object'?res:instance;
}
```

### 10.模拟 object.create

`Object.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的 `__proto__`

````
```js
// 模拟 Object.create

function create(proto) {
  function F() {}
  F.prototype = proto;

  return new F();
}
````

### 11 实现类的继承

思路：

- 继承属性：通过 call 拿到父类的属性值
- 继承方法并返回一个新的对象：child.prototype=Object.create(Parent.prototype),Object.create 是创建了父类原型的副本，与父类原型完全隔离
- 更改子类的构造函数

```js
function Parent() {
  this.name = "parent";
  this.play = [1, 2, 3];
}
function Child() {
  Parent.call(this);
  this.type = "child";
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```

### 12 对迭代器实现

iterator 产生背景：

JS 原生的集合类型数据结构，只有`Array`（数组）和`Object`（对象）；而`ES6`中，又新增了`Map`和`Set`。四种数据结构各自有着自己特别的内部实现，但我们仍期待以同样的一套规则去遍历它们，所以`ES6`在推出新数据结构的同时也推出了一套**统一的接口机制**——迭代器（`Iterator`）。

> `ES6`约定，任何数据结构只要具备`Symbol.iterator`属性（这个属性就是`Iterator`的具体实现，它本质上是当前数据结构默认的迭代器生成函数），就可以被遍历——准确地说，是被`for...of...`循环和迭代器的 next 方法遍历。 事实上，`for...of...`的背后正是对`next`方法的反复调用。

```js
// 通过调用iterator，拿到迭代器对象
const iterator = arr[Symbol.iterator]();

// 初始化一个迭代结果
let now = { done: false };

// 循环往外迭代成员
while (!now.done) {
  now = iterator.next();
  if (!now.done) {
    console.log(`现在遍历到了${now.value}`);
  }
}
```

### 13 实现迭代器生成函数

```js
function iteratorGenerator(list) {
  let idx = 0;
  let len = list.length;
  return {
    next: function () {
      let done = idx >= len;
      var value = !done ? list[idx++] : undefined;
      return {
        done,
        value,
      };
    },
  };
}
```

### 14 const 定义常量实现

思路：
由于 ES5 环境没有 block 的概念，所以是无法百分百实现 const，只能是挂载到某个对象下，要么是全局的 window，要么就是自定义一个 object 来当容器

```js
export var _const = function (data, value) {
  global.data = value;
  Object.defineProperty(global, data, {
    enumerable: false,
    configurable: false,
    get: function () {
      return value;
    },
    set: function (data) {
      if (data !== value) {
        throw new TypeError("Assignment to constant variable.");
      } else {
        return value;
      }
    },
  });
};
```

### 15 柯里化函数

思路：

> 柯里化的定义：接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数。

当柯里化函数接收到足够参数后，就会执行原函数，如何去确定何时达到足够的参数呢？

**有两种思路：**

- 通过函数的 `length` 属性，获取函数的形参个数，形参的个数就是所需的参数个数
- 在调用柯里化工具函数时，手动指定所需的参数个数

将这两点结合一下，实现一个简单 curry 函数

```js
export const curry = function (fn, ...args) {
  const length = fn.length;
  return function () {
    args = args.concat(Array.prototype.slice.call(arguments));
    if (args.length < length) {
      return curry.call(this, fn, ...args);
    } else {
      return fn.apply(this, args);
    }
  };
};
```

### 16.实现函数的类型判断

```js
export const getType = function (obj) {
  if (obj === null) {
    return String(obj);
  }
  return typeof obj === "object"
    ? Object.prototype.toString
        .call(obj)
        .replace("[object ", "")
        .replace("]", "")
        .toLowerCase()
    : typeof obj;
};
```

### 17.实现 map 方法

```js
Array.prototype.myMap = function (fn, context) {
  var arr = Array.prototype.slice.call(this);
  var mappedArr = [];
  for (var i = 0; i < arr.length; i++) {
    mappedArr.push(fn.call(context, arr[i], i, this));
  }
  return mappedArr;
};
```

### 18.实现 reduce 方法

思路：

- 1.初始值不传怎么办？
  如果传的话，默认使用初始值，如果不传的话，那么使用数组的第一项
- 2.回调函数的参数有哪些，返回值如何处理。
  把初始值、当前值、索引、当前数组返回去。调用的时候传到函数参数中

```js
Array.prototype.myReduce = function (fn, init) {
  const arr = Array.prototype.slice.call(this);
  let res, startIndex;
  res = init ? init : arr[0];
  startIndex = init ? 0 : 1;
  for (var i = startIndex; i < arr.length; i++) {
    res = fn.call(null, res, arr[i], i, this);
  }
  return res;
};
```

### 19.实现 flat 方法

思路

- 1.使用递归
- 2.递归返回的结果进行合并

```js
Array.prototype.myFlat = function () {
  const arr = this;
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      let result = arr[i].myFlat();
      res = [...res, ...result];
    } else {
      res.push(arr[i]);
    }
  }
  return res;
};
```

### 20.对象扁平化

思路

1.实现思路同上

```js
Object.prototype.flatObj = function () {
  const res = {};
  const flat = function (obj) {
    Object.entries(obj).forEach((item) => {
      if (Object.prototype.toString.call(item[1]) === "[object Object]") {
        flat(item[1]);
      } else {
        res[item[0]] = item[1];
      }
    });
  };
  flat(this);
  return res;
};
```

### 21.实现 compose 函数(本质是一个中间件)

思路：

组合多个函数，从左到右，比如：compose(f, g, h) 最终得到这个结果 (...args) => f(g(h(...args))).

```js
function compose(...funcs) {
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(
    (a, b) =>
      (...args) =>
        a(b(...args))
  );
}
```

### 22.Object.is 方法

思路：Object.is 和===差不多，都是用来对比两个值是否相等的

首先是 Object.is 和===区别是什么

- NaN 在===是不相等的，在 Object.is 是相等的

- +0 和-0 在===是相等的，在 Object.is 是不相等的

```js
Object.prototype.myIs = function (first, second) {
  if (first !== second) {
    // 当前情况下，只有一种情况是特殊的，只需要判断是否为NaN
    // first和y同时为NaN，返回true
    return first !== first && second !== second;
  }
  return first !== 0 || 1 / first === 1 / second;
};
```
